# Adding Stateful Code Execution Functionality

To add stateful code execution, the current stateless "one-shot" architecture
needs to be evolved to support persistent sessions. This involves shifting from
a single, shared environment that is reset after each run, to managing multiple,
isolated, and persistent environments for each user session.

## Key Architectural Changes

1. **Introduce a Session Manager:**
   - **Purpose**: A new manager class (`PyodideSessionManager`) will be
     responsible for the lifecycle of `PyodidePythonEnvironment` instances. It
     will create, store, retrieve, and destroy these environments based on a
     unique session ID.
   - **Function**: This ensures each user session is isolated and that state
     (variables, functions, modules) from one session does not leak into
     another.

2. **Adapt `PyodidePythonEnvironment` for Persistence:**
   - **Lifecycle**: The `init()` method (which pre-loads packages) will be
     called only **once** at the beginning of a session, not before every
     execution.
   - **Execution vs. Cleanup**: The `cleanup()` method will be modified to only
     reset transient state for a single run (e.g., clearing `stdout`/`stderr`
     buffers), rather than reloading the entire environment. A new `destroy()`
     method will be added to completely terminate the Pyodide instance when the
     session ends, freeing up resources.

3. **Implement Stateful File Handling:**
   - **Persistence**: Files created during one execution must persist in the
     virtual filesystem to be accessible in subsequent executions within the
     same session.
   - **Smarter Output Detection**: The logic for detecting output files must be
     updated. The new approach is to take a "snapshot" of the filesystem's state
     _before_ code execution and compare it to the state _after_. The difference
     between these two snapshots reveals the exact files that were generated by
     the most recent execution.
